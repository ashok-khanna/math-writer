<!DOCTYPE html>
<html lang="en">
<head>
  <title>Math Writer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="writer.css">
	<script src="tinymce/tinymce.min.js" referrerpolicy="origin"></script>
  <script src="writer.js" referrerpolicy="origin"></script>
  <script src="https://buttons.github.io/buttons.js"></script>
  <script>
window.MathJax = {
    "fast-preview": {
                disabled: true
        },
    extensions: ["tex2jax.js", "asciimath2jax.js"],
    jax: ["input/TeX", "input/AsciiMath", "output/HTML-CSS"],
    displayAlign: "left",
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    }, 
    asciimath2jax: {
      delimiters: [['$','$'], ['`','`']],
      preview: [""]},
    "HTML-CSS": { fonts: ["STIX"] }
  }
  </script>
<script type="text/javascript" sync
  src="MathJax-2.7.7/MathJax.js">
</script>

</head>
<body>
<main id="main">
<div id="github"><a class="github-button" href="https://github.com/ashok-khanna/ashok-khanna.github.io" data-color-scheme="no-preference: light; light: light; dark: light;" data-size="large" aria-label="Use this template ashok-khanna/ashok-khanna.github.io on GitHub">View on GitHub</a></div>
<div id="star"><a id="star" class="github-button" href="https://github.com/ashok-khanna/ashok-khanna.github.io" data-color-scheme="no-preference: light; light: light; dark: light;" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star ashok-khanna/ashok-khanna.github.io on GitHub">Star</a></div>
<div id="text">https://writer.math.dev</div>

  <div id="top-gutter"></div>
  <div id="second-gutter"></div>
  <div id="editor-button" class="button bt-active" onclick="editor()">Editor</div>
  <div id="preview-button" class="button bt-inactive" onclick="preview()">Preview</div>
  <div id="shortcut-button" class="button bt-inactive" onclick="shortcut()">Shortcuts</div>
  <div id="help-button" class="button bt-inactive" onclick="help()">Read Me</div>
  <div id="third-gutter"></div>

  <div id="main-screen"><div id="editor">
    <div id="tinymce" class="dfree-body" contenteditable="true" style="position: relative;" spellcheck="false"></div></div>
    <div id="preview">`sum_(i=1)^n i^3=((n(n+1))/2)^2`</div>
    <div id="shortcut">Add shortcuts here</div>
    <div id="help">
      <p>1.0 Parsing Logic
  - * - * - * - * - * - * -
  <p>It is important to keep the rules simple to make them easier to understand and train into "muscle memory" of the user, and to minimise the chance of clashing rules or bugs, due to overly complex rules that must interact with each others.</p>
  
  <p>There will likely be an explosion of various scenarios due to the inherent expressiveness and complexity of mathematical language. We want to minimise this explosion without hampering the input and retrieval of information.</p>
  
  <p>Mathematical expressions can be divided into four elements:</p>
  
  <h4>Relations: = ≠ ⊂ ⊃ ∊ > < ≤ ≥ etc.</h4>
  <p>Relations define conditions and the highest level of a mathematical expression. In our model, we are mostly working with conditions and thus a mathematical sentence is only achieved by the presence of a relation. That is, x = y is a mathematical sentence whilst x + y is not.</p>
  
  <h4>Objects: x, y, 1, 2, (x + y), etc.</h4>
  <p>Objects represent the variables of our mathematical expressions. They can either be generic variables, denoted by letters, literal numeric constants, such as 1 or 2 or 2.5, or even more complex compound elements such as the object generated by x + y.</p>
  
  
  
  <h3>Operators: + - / * ∪ ∩ etc.</h3>
  
  <p>Operators generate new mathematical objects from their input objects, e.g. the + sign in x + y is an operator and x + y represents a new object generated by adding x to y. Note that "x + y" is an object, while "+" is the operator.</p>
  
  <h3>Logic Operators: ∧ ∨ ¬ ⇔ → ∃ ∀</h3>
  <p>Logic operators are similar to operators but apply to full relations (conditions), creating new ones. E.g. x + y = 3 → y + x = 3 shows a transformation (creation) of a new relationship y + x = 3 from the starting relation
  </p>
  <p>In summary: Relations are mathematical sentences, logic operators create mathematical paragraphs, objects are mathematical words, while operators are conjunctions that aide in the creation of new mathematical words. Since meaning is only achieved in our model once we get to the state of a relation, I will not say operators create "phrases", which wikipedia defines as a group of words with meaning. Rather, we can consider relations as phrases
  as well as sentences. Similarly logic operators can be thought of to create sentences as well as paragraphs. These analogies are not important, it is only to help visualise the approach we take.</p>
  
  <p>Basic Principles:</p>
  
  <p>One overarching principle is that there should be an unambiguous way to distinguish between "english" and "math". As an example, "The theorem x + y = y + x holds true for all x and y in R". It is obvious here that x + y = y + x is an equation and x, y and R are variables.</p>
  
  <p>The reason for this is twofold - the presence of mathematical characters such as + and =, and more importantly, the fact that single letters are mostly not words in the english language (there is no words "x" "y" and "R").</p>
  
  <h3>[OBJECTS AS SINGLE LETTERS]</h3>
  
  <p>OBJECTS are identified by single letters (for variables) or numbers (for literal numeric constants). The reason why we do not generalise numbers to an abstract form and rather use literals is to shortcut their computation (otherwise we would have to trace them back to first principles always to calculate their value). We rather have to readily
  convert 3 + 5 to 8 vs. having to trace back to the definition of natural numbers and addition to get back to this point.</p>
  
  <p>There is no clash between the above definition and most letters since single letters are not words in the english language. The two exceptions are "a" and "i". We will take a view that we should not be writing mathematics in the first-person, thus, "i" will refer to the variable "i" and not the word "I". Thus in the sentence "Substituting i into x", "i" is a variable and not a reference to ourselves.
  </p>
  
  <p>In contrast, "a" is a very frequently used word. But, "a" is also a very common variable symbol. For now, we will use "a" to refer to the variable "a" as initial work has shown that its not a word that is commonly used in maths. We may reverse this in the future. Thus, for now, to refer to the word "a", we will escape it with ";a".</p>
  
  <h3>[ESCAPING --> : for variables, ; for text]</h3>
  
  <p>This brings us to the next item. We can escape any text to mean a variable by using ":", e.g. ":as" refers to the variable "as" (we will shortly see later, that we would otherwise override this as the word "as"). We can escape any variable to mean text with ";", e.g. ";a" or ";b" (although b is not a word, so this is not something we likely ever do).</p>
  
  <h3>[MULTI-LETTER OBJECTS]</h3>
  <p>By allowing single letters to reference variables We have 26 variable places to use. Its unlikely we will need more objects for most questions (and we will introduce other mechanisms for more common patterns such as x1 + ... + xn). But sometimes, it would be nice to refer to objects like "ab" or "ac". A couple of things here. First, there are only so many legal two letter words in the English alphabet. However, these are much more commonly used than "a" or "i". E.g. we would be frequently using "by", "as" or "to" as words in our work. Thus, we define a list of two letter words that when they appear, they represent normal words. For the rest of two letter combinations, they will be treated as variables. Thus in "Substituing abin x by axiom", ab is a mathematical object, while
  by and in are normal words.</p>
  
  <p>The list of words that are treated as english words is by, do, go, id, if, in, is , it, my, no, of, on, or, to, up, us (hopefully that is comprehensive). Now the question is, do we treat two letter objects like "ab" as the object "ab" or "a * b"? In general math usage, we would like to do ab and xy as products and thus two letter math objects expand to (_ * _)</p>
  
  <p>I.e. xy expands to (x * y). Note that this also means 1/xy is interpreted as 1/(x * y). This is ideal in my opinion as it would be a chore to always bracket it out. Thus in the division vs multiplication precedence we treat xy to take precedence over any nearby division operations. However, 1/x*y would result in ambigiuity and we should correctly write this as 1/(x * y).</p>
  
  <p>But then, we would also like to use more descriptive variable names from time to time, e.g. red + blue + green = white. We can do this by escaping the character e.g. :red. Thus :xy refers to "xy" and not "(x * y)"
  Thus the expansion of xy into (x * y) is a special case and we can default back to the primitive variable reading by overriding with ":". This helps in terms of building consistency in the program as : will always mean literal variable names.</p>
  
  <p>Finally note, that all words > two letters are assumed to be english, unless escaped appropriately.</p>
  
  <h3>[TREATMENT OF NUMBERS]</h3>
  <p>We have covered the treatment of letters. Now let us consider numbers. Obviously numbers by themselves
  refer to objects, e.g. in "Add 1 to 3", and will be treated as such.</p>
  
  <p>However, we want to add a bit more functionality. First note, that it is nonsensical in english to have
  a digit within a word. Thus a1pha or elit3 are never legal english words. Thus we will assume these always
  to be some sort of mathematical objects.</p>
  
  <p>Secondly, note that a common design pattern is to have objects with subscripts, e.g. x1 + ... + xn
  Thus, any number following a letter will be assumed to be a subscript object, e.g. "x1". We can explicitly
  subscript with "_", thus "x1" is equivalent to "x_1".</p>
  
  <p>The next question would be whether "x2" refers to x_2 or (x * 2). As a general rule, we will state that
  we should write numbers before variables, i.e. 2x is the correct form and x2 should be avoided where possible
  Thus x2, x3 etc. will always refer to subscripted variables.</p>
  
  
  <h3>[RESERVED SINGLE LETTERS]</h3>
  <p>But what about "xn". Is this (x * n) or x_n? Of course we can avoid this problem by being explicit (i.e.
  writing out either x_n or (x * n), however the name of the game here is elegant shorthand. First note,
  that the common indice letters are i, j, k, l, m. However, this is not true, as people also frequently
  indice with r, s, p, q, etc.</p>
  
  <p>Well, "n" is definitely most commonly used for indices and not frequenlty for variables. "m" also is
  commonly used when there are two indices at play.</p>
  
  <p>Thus, the default would be that n and m are assumed to be indices, while the rest are assumed to be
  variables. Thus xm refers to x_m while xp refers to (x * p). Where you need to override this behaviour,
  or work with additinal complexity, use the explicit forms Actually, lets do j, k, l as well. This gives us 5
  levels of indices to use as defaults and these letters I haven't seen much as variable names</p>
  
  <p>"i" is a special case, because its frequently used to represent iota. We will follow this approach here.
  Thus xi refers to x iota. Simlarly, e will be reserved for euler's constant.</p>
  
  <h3>[MULTI LEVEL INDICES]</h3>
  <p>Multi-level indices are common (when cycling through two series. We will use the following form: x1,2
  or x2,b. Note here, due to the presence of the comma it is unambigious that the letter representing the
  second level of indice is an indice and we can use any letter here, not only the five noted above
  which are reserved only for first level indices. Similaly we can do x1,d,3 to show three indice levels</p>
  
  <h3>[OPERATORS]</h3>
  <p>Operators such as + - * / are obviously mathematical
  objects. The words preceding and succeeding these
  objects can also be assumed to be objects and not
  text, e.g. we wouldn't ever write "as this is true,
  by + 3" and not assume by refers to the object by
  and not the word by. However, given the few
  number of clashes, this added clarity does not add
  much, but is worth it anyway.</p>
  
  <p>More importantly, the question is what does x + y
  represent? Note that we are interested in objects
  and x is an object and so is x + y. Thus both
  are valid: "Substituting x into equation 3" and
  "Substituting x + y into equation 3". In this
  example, both represent the same level of object
  that is being substituted into the form.</p>
  
  <p>The reality is that the FORM of a sentence is
  defined by the arrangement of text and objects.
  Text, e.g. "into" delimits objects and ojects
  e.g. "x + y" delimits textual areas. E.g. "3"
  delimits "into equation"</p>
  
  <p>Spaces delimit elements within a textual area
  or within an mathematical object. This is
  common sense.</p>
  
  <h3>[RELATIONS & LOGIC OPERATORS]</h3>
  <p>From a text vs. math perspective, relations
  and logic operators are treated the same as
  operators. One thing to note is unary vs.
  binary operators / relations. E.g. in "Since
  ¬ x, we have x = False", we cannot say that
  "since" is a mathematical object, so we
  need to treat unary and binary operators
  and relations seperately (but applying the
  same principles that they help guide what is
  text vs. math.</p>
  
  <h3>[Delimiting between objects & relations]</h3>
  <p>To avoid having to do too much parentheses
  to explictly group objects, we can rely on
  relations & logical operators as delimiters.
  E.g. x + y = 3 ⇒ x = 3 - y is unambigous
  and refers to ((x + y) = 3) ⇒ ((x = 3) - y)</p>
  
  <p>Similarly, x > 3 ∧ y < 3 ⇒ x/y > 1 refers to
  ((x > 3) ∧ (y < 3)) ⇒ (x/y > 1) un ambgiously.</p>
  
  <h3>[ROLE OF PARENTHESIS] [L TO R READING]</h3>
  <p>In fact, whilst spaces clearly delimit objects,
  we can also delimit by objects of another type
  e.g. x/y is the same as "x / y".</p>
  
  <p>How about x + y / b? Due to BODMAS convention,
  we know this is x + (y / b). To be explicit,
  we use parenthesis. This also applies to
  other rules, e.g. (xa)1 is (xa)_1 etc. and
  (by) represents (b * y) and not the word by.
  Note that if we wanted to refer to the
  variable "xa" in (xa)1, we would write (:xa)1
  and if we wanted to refer to (xa) * 1 we would
  write (xa) * 1 and not (xa)1. "xa1" would refer
  to x * a1 (left to right decomposition). "alpha"
  would refer to ((a_l) * p * h * a).</p>
  
  <p>{} and [] are equivalent parenthesis.</p>
  
  <p>Note that in L2R Reading, parenthesis overrides.
  Thus we have to delimit first by parenthesis
  and then apply left 2 right reading, i.e. 
  parenthesis, like spaces or operators, delimits objects
  </p>
  <p>Thus in (xa)b, we cannot do x * "a)b", even though
  that is nonsensical. Rather, we first delimit into
  "(xa)" and "b" and then convert "(xa)" to "(x * a)".</p>
  
  <p>What about "(xa) b"? This would be delimited again into
  (xa) and b, but there is no operator in between so
  this should return an error (or maybe we can use as
  lists...to be determined).</p>
  
  <p>This doesn't help us with "a". Because if we have "The
  equation x + a = b is a wonderful example". Obviously,
  "a" here is a word, but it is also a valid object,
  the issue we outlined occurs when we have two objects
  without an operator or relation between them and not
  when there is text delimiting (since "a" here refers
  to the place, similar to 3 in "equation 3".</p>
  
  <p>However, to get around this, we could first search for
  forms where "a" is a place, and then as we will
  in nearly all cases not find one, search for it as a
  word :) This is a better way, then assuming it is text
  and then searching the other way round, as its much
  more likely to be used as an object than as text. </p>
  
  <h3>[ORDER OF PRECEDENCE]</h3>
  <p>Follow BODMAS, brackets over others. Then logical
  operators, then relations, then operators, then spaces
  i.e. we trim the spaces later. Actually spaces are
  just used as whitespace and not required? This is
  Correct, based on earlier discussion regarding
  invalidity of "b c" vs. "b + c". However spaces
  are used to seperate text and objects. Thus the
  first thing is to do spaces to seperate the two
  and then combine successive objects into one where
  possible (refer to notes above re unary & binary)</p>
  
  <p>Any object delimited by text is a single object
  as far as we are concerned, although we would
  transpose its actual more complex size to the
  function being called</p>
    </div></div>
</main>
<script>
  document.getElementById("tinymce").focus();
</script>
</body>
</html>



